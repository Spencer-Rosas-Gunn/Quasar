const info = @import("info.zig");
const pmm = @import("../pmm.zig");

const PageTableEntry_t = packed struct {
    present: bool,
    writeable: bool,
    user_access: bool,
    write_through: bool,
    cache_disabled: bool,
    accessed: bool,
    dirty: bool,
    size: bool,
    global: bool,
    _rsvd1: u3 = false,
    page_ppn: u40,
    _rsvd2: u11 = 0,
    execution_disabled: bool,

    fn init(self: *PageTableEntry_t) void {
        self.present = true;
        self.writeable = true;
        self.user_access = true;
        self.write_through = true;
        self.cache_disabled = false;
        self.accessed = true;
        self.dirty = true;
        self.size = false;
        self.global = false;
        self.execution_disabled = false;
    }

    pub fn index(self: *PageTableEntry_t) *[512]PageTableEntry_t {
        if (self.page_ppn == 0) {
            self.page_ppn = pmm.new().page;
            self.init();
        }

        return @ptrFromInt(@as(usize, self.page_ppn));
    }

    pub fn fromInt(ptr: anytype) PageTableEntry_t {
        var self: PageTableEntry_t = undefined;
        self.init();
        self.page_ppn = @intCast(ptr);
        return self;
    }
};

const Pointer_t = packed struct {
    pml4: u9,
    pdpt: u9,
    pdt: u9,
    pt: u9,
    offset: u12,
};

// Address Space
pub const AddressSpace_t = *anyopaque;

// Map physical address "src" to virtual address "dest"
pub fn mmap(src: *anyopaque, dest: *anyopaque, addr_space: AddressSpace_t) void {
    const page_num = @intCast(@intFromPtr(src) / info.page_size);
    const ptr: Point_t = @bitCast(dest);
    const space: *[512]PageTableEntry_t = @ptrCast(AddressSpace_t);

    const pml4 = raw_addr_space[ptr.pml4].index();
    const pdpt = pml4[ptr.pdpt].index();
    const pdt = pdpt[ptr.pdt].index();
    const pt = &pdt[ptr.pt].index()[0];

    pt.* = PageTableEntry_t.fromInt(page_num);
}

// Unmap virtual address "ptr"
pub fn munmap(ptr: *anyopaque, addr_space: AddressSpace_t) void {
    // ...
}
